### 数组排序

#### 冒泡排序（BubbleSort）

  1. 每次循环找到最大数字，移到最后。
  2. 解法：循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。这样一次循环之后最后一个数就是本数组最大的数。下一次循环继续上面的操作，不循环已经排序好的数。
  3. 优化：当一次循环没有发生冒泡，说明已经排序完成，停止循环。
  4. 时间复杂度：O(n2)
  5. 空间复杂度：O(1)
  6. 稳定性：稳定

#### 堆排序 （HeapSort）
  1. 解法：创建一个大顶堆，大顶堆的堆顶一定是最大的元素。
  2. 交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。
  3. 从后往前以此和第一个元素交换并重新构建，排序完成。

#### 插入排序 （InsertSort）
  1. 解法： 将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。
  2. 时间复杂度：O(n2)
  3. 空间复杂度：O(1)
  4. 稳定性：稳定

#### 归并排序 （MergeSort）

  1. 解法：该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序，若将两个有序表合并成一个有序表，称为二路归并；
  2. 分割：将数组从中点进行分割，分为左、右两个数组，递归分割左、右数组，直到数组长度小于2；
  3. 归并：如果需要合并，那么左右两数组已经有序了。创建一个临时存储数组temp，比较两数组第一个元素，将较小的元素加入临时数组。若左右数组有一个为空，那么此时另一个数组一定大于temp 中的所有元素，直接将其所有元素加入temp；
  4. 时间复杂度：对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。
  5. 空间复杂度：需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。
  6. 稳定性：归并排序是一种稳定的排序。

#### 快速排序（QuickSort）
  1. 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小
  2. 再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列
 
  3. 时间复杂度： 平均O(nlogn)，最坏O(n2)，实际上大多数情况下小于O(nlogn)
  4. 空间复杂度： O(logn)（递归调用消耗）
  5. 稳定性： 不稳定

#### 选择排序 （SelectSort）

  1. 每次循环选取一个最小的数字放到前面的有序序列中。
  2. 时间复杂度： O(n^2)
  3. 空间复杂度：O(1)
  4. 稳定性： 不稳定